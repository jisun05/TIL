ğŸ“Œ Problem Name
287.Find the Duplicate Number

ğŸ—‚ Category / Type
Cycle Detection (Floydâ€™s Tortoise and Hare) / Two Pointers

âŒ What Went Wrong / Why It Failed
Initially tried to use sorting with two pointers, which is unnecessary and less efficient.
Misunderstood the problem as needing a brute-force or HashSet-based approach, violating the O(1) space requirement.
Incorrectly treated values as values, not as indices â€” missing the core pointer-chasing structure.
Missed the fact that the arrayâ€™s structure naturally forms a cycle due to the pigeonhole principle.
Didn't leverage Floyd's algorithm because the problem didnâ€™t look like a cycle problem at first glance.

ğŸ§  Key Takeaways / What I Learned
When nums.length == n + 1 and values are in [1, n], the structure guarantees a cycle.
You can treat nums[i] as a pointer to the next index â€” like a linked list.
Use Floydâ€™s Tortoise and Hare:
slow = nums[slow]
fast = nums[nums[fast]]
The point where slow and finder meet again is the start of the cycle = duplicate number.
This approach gives O(n) time and O(1) space â€” optimal for the constraints.


**[2025-05-07 Review]**
Avoid sorting: Using Arrays.sort(nums) alters the input and costs O(n log n), violating the â€œno modificationâ€ constraint.
Incorrect pointer setup: Reinitializing slow and fast inside the loop prevents them from advancing through the cycle.
No true traversal: Since pointers never move consecutively, they canâ€™t follow the underlying cycle structure.
Broken mapping: Sorting destroys the original index-to-value relationships, so no cycle exists and the pointers will never meet.

ğŸ± Point
Recognize that the problem reduces to cycle detection via pointer redirection.
The pigeonhole principle is key: n + 1 elements in a [1, n] range must produce a duplicate.
Donâ€™t rely on sorting or extra memory â€” the structure of the input itself gives enough information.
Floydâ€™s algorithm is not just for linked lists â€” it works on array-based pointer graphs too.


ğŸ“ Problem Log1

ğŸ“Œ Problem Name
- 167. Two Sum II - Input Array Is Sorted(https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

ğŸ—‚ Category / Type
- Two Pointers

ğŸ” My Initial Approach
- Moving the pointers based solely on whether `numbers[left]` is less than or greater than `numbers[right]`
- I was focusing on comparing individual values instead of their sum

âŒ What Went Wrong / Why It Failed
- Mistakenly moved pointers based on value comparison instead of comparing the sum to the target
- This led to incorrect pointer movement and missed the correct answer

âœ… Final Solution Summary
- Used two pointers starting from both ends of the array
- Compared the sum of `numbers[left] + numbers[right]` to the target:
  - If sum == target â†’ return the indices
  - If sum < target â†’ move left pointer
  - If sum > target â†’ move right pointer
- Took advantage of the array being sorted to efficiently find the pair in O(n) time

ğŸ§  Key Takeaways / What I Learned
- Always base pointer movement on the actual goal of the problem â€” in this case, the "sum", not the individual values
- Recognized that the sorted nature of the array allows for a two-pointer strategy

ğŸ’¬ Additional Thoughts / Retrospective
- From my perspective, using a nested for loop seemed more readable when the input array size is relatively small.


ğŸ“Œ Problem Name
-125. Valid Palindrome

ğŸ—‚ Category / Type
-Two Pointers / String Manipulation

ğŸ” My Initial Approach
-Used two pointers to compare characters from both ends of the string

-Initially handled all logic using only if statements without else if, which caused conditions to overlap and logic to break

-Didn't properly skip non-alphanumeric characters before comparison, which led to incorrect results

âŒ What Went Wrong / Why It Failed
-All conditions were handled with if blocks, so the control flow wasnâ€™t clear and failed in certain edge cases

-I was checking and comparing characters even when they werenâ€™t valid (i.e., not letters or digits)

-This resulted in errors when comparing invalid characters, even though they shouldâ€™ve been skipped

âœ… Final Solution Summary
-Used two pointers, one from the start and one from the end of the string

-Skipped non-alphanumeric characters using <<<<Character.isLetterOrDigit>>>>>
-Compared characters after converting them to lowercase       

ğŸ§  Key Takeaways / What I Learned
-It's important to return early (return false) when the failure condition is clear â€” this improves both readability and efficiency
-Character.toLowerCase(s.charAt(first)) 
-Character.isLetterOrDigit(s.charAt(end))

**[2025-04-22 Review]**  
- Encountered a compilation error due to using `Char` instead of `Character`.  
- Incorrectly used `s.char(first)` instead of `s.charAt(first)`, resulting in a method not found error.

ğŸ’¬ Additional Thoughts / Retrospective
- In the future, Iâ€™d like to improve the efficiency by returning false as soon as a mismatch is found, instead of continuing unnecessary checks



